// let, const
const func = [];

for (let i = 0; i < 3; i++) {
  func[i] = function () {
    return i;
  };
}

for (let i = 0; i < func.length; i++) {
  console.log(func[i]());
}
//이 함수는 아래 var과 다르게 반복할 변수 i와 j를 let으로 선언 했기에 선언된 코드 블록에 따라 새로운 렉시컬
//환경을 제공하므로 굳이 클로저를 만들지 않아도 된다

//var
var func2 = [];

for (var i = 0; i < 3; i++) {
  func2[i] = function () {
    return i;
  };
}

for (var j = 0; j < func2.length; j++) {
  console.log(func2[j]());
}

//func 배열의 i인덱스에 있는 func[i]()를 실행 할 경우 i가 반환 된다 하지만 i의 값은 반환 되기 전까지
//i의 값은 모르기에 콘솔로 찍을 수 없다(콘솔로 func을 찍을 경우 익명 함수들만 나옴)하지만 func의 내부의
//함수들은 각각 인자를 받고 그것을 바로 반환하는데 func[1]이라고 특정 인덱스의 함수를 찍어도 익명 함수만 나온다

//그리고 여기서 var로 변수를 선언하고 그렇지 않은 예를 보았을때 큰 차이가 있는데

//var예제를 보면 변수 i는 var로 생성한 전역 변수이기 때문에 반복문이 실행할 수록 i의 값이 바뀌어서 결국에
//24째 줄에 func2의 j번째 함수를 호출 한 들 i를 반환하고 그 i는 반복문을 거쳐 3이 돼서 3만 찍힌다

//이를 해결하기 위해서 클로저를 사용하여 인자를 필요로 하는 즉시 실행함수를 만들고 그 함수는 즉시 실행 함수의
//인자를 반환한 다음 즉시실행함수에 i를 인수로 주면 클로저를 활용하여 문제를 해결 할 수 있지만
//위에 let과 const를 이용해 더 쉽게 풀 수 있다
